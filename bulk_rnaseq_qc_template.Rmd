---
title: "bulk_RNAseq_QC"
author: "DTG"
date:  "`r Sys.Date()`"
output: 
  rmdformats::robobook:
    fig_width: 9
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo=FALSE, fig.width = 6, fig.height = 4, dev='png')
library(tidyverse)
library(ggforce)
library(grid)
library(ggpubr)
library(yaml)
library(DESeq2)
library(EDASeq)
library(DT)
library(shiny)
library(EnhancedVolcano)
library(tools)
library(ComplexHeatmap)
library(gridExtra)
library(gtable)
library(circlize)
library(openxlsx)
library(reshape2)
library(kableExtra)
library(rlang)
library(forcats)
library(gtools)
library(RColorBrewer)
library(fgsea)
library(MatrixGenerics)
#library(plyr)

counts <- DESeq2::counts
#config <- yaml.load_file("config.yaml")
source("functions.R")
```

<style type="text/css">
.book .book-body .page-inner {
  max-width: 1600px;
  margin-left: auto;
  margin-right: auto;
}
</style>

## Study overview

```{r reset_analysis_obj, eval=TRUE, include=FALSE}
# This is moved out of the setup block to avoid accidentally overwriting your
# analysis object when restarting a session
analysis = list()
```

```{r load_config, include=FALSE}
# Store config with results object for record keeping
analysis$config <- yaml.load_file("config.yaml")
```

```{r sample_metadata_setup}
## Build your own
analysis$sampleTable <- data.frame(matrix("", 0, 3, dimnames=list(c(), c("FileID", "SampleID", "Group"))), stringsAsFactors=TRUE)

## Or load from file 
analysis$sampleTable <- read.table("exp_design_template.txt", header=T, stringsAsFactors = FALSE)
#analysis$sampleTable <- analysis$sampleTable %>% dplyr::arrange(across(all_of(analysis$config$sampleGrouping)))
analysis$sampleTable <- as.data.frame(sapply(analysis$sampleTable, as.factor))

knitr::kable((analysis$sampleTable), position='center', table.attr="style='width:100%;'", format='html') %>%
    kable_styling(full_width = TRUE)

# Store the order you'd like samples to appear in figure
# Order is determined by sampleGrouping parameters in config
# But you could also manually specify it here if there aren't easy rules
sample_order <- fct_inorder(as.character(analysis$sampleTable$SampleID))
```

```{r read_counts_tables, include=FALSE}
analysis$samplefileIDs <- dir(file.path(analysis$config$rootDir, analysis$config$alignmentDir))
analysis$samplefileIDs <- analysis$samplefileIDs[analysis$samplefileIDs %in% analysis$sampleTable$FileID]
analysis$sampleSTARReads <- sapply(analysis$samplefileIDs, function(sid) {read_tsv(paste0(
  dir(file.path(analysis$config$rootDir, analysis$config$alignmentDir), pattern = sid, full.names = TRUE),
  "/",sid,
  analysis$config$STARreadSuffix
), col_names = c("gene_id","unstranded_count","sense_count","antisense_count"),
  col_types = c(gene_id = col_character(),
  unstranded_count = col_double(),
  sense_count = col_double(),
  antisense_count = col_double()))},
simplify = FALSE,
USE.NAMES = TRUE)
```

```{r dds, include=FALSE}
analysis$mapBins <- do.call(cbind,
                            sapply(analysis$sampleTable$FileID, 
          function(sid){analysis$sampleSTARReads[[sid]][,paste0(analysis$config$libraryType,"_count")][c(1:4),]}))
rownames(analysis$mapBins) <- analysis$sampleSTARReads[[1]][c(1:4),][["gene_id"]]
colnames(analysis$mapBins) <- recode(as.character(unlist(strsplit(analysis$sampleTable$SampleID, paste0(".", analysis$config$libraryType, "_count")))), !!!setNames(analysis$sampleTable$SampleID, as.character(analysis$sampleTable$FileID)))
 
raw_counts <- do.call(cbind,sapply(analysis$sampleTable$FileID, function(sid){analysis$sampleSTARReads[[sid]][,paste0( analysis$config$libraryType, "_count")][-c(1:4),]}))
colnames(raw_counts) <- recode(as.character(unlist(strsplit(analysis$sampleTable$FileID, paste0(".", analysis$config$libraryType, "_count")))), !!!setNames(analysis$sampleTable$SampleID, as.character(analysis$sampleTable$FileID)))
rownames(analysis$sampleTable) <- analysis$sampleTable$SampleID
analysis$sampleTable <- analysis$sampleTable[colnames(raw_counts),]

## safety check to make sure metadata and samples are properly associated
stopifnot(colnames(raw_counts) == analysis$sampleTable$SampleID)

analysis$dds <- DESeqDataSetFromMatrix(raw_counts,
  analysis$sampleTable,
  design = as.formula( ~ 1)
)
analysis$mapBins <- rbind(analysis$mapBins,"N_identified" = colSums2(DESeq2::counts(analysis$dds)))
```

## QC {.tabset}

### Mapping

Outcomes from mapping reads to reference genome. Reads need to be 'identified' or successfully mapped to a single feature to be used for gene expression analysis.

```{r mapping_plot}
mapping_plot(analysis$mapBins)
```

```{r remove_samples}
if (!is.null(unlist(analysis$config$dropSamples))){
  out <- paste0("Sample(s)\n", paste0(analysis$config$dropSamples, sep=", ", collapse = ''),"\nbeing removed from downstream analysis per user specification.") 
  analysis$mapBins <- analysis$mapBins[,!colnames(analysis$mapBins) %in% analysis$config$dropSamples]
  analysis$ddsDrop <- analysis$dds[,!(colnames(analysis$dds) %in% analysis$config$dropSamples)]
  sample_order <- sample_order[!(sample_order %in% as.factor(analysis$config$dropSamples))]
  cat(out)
} else {
  analysis$ddsDrop <- analysis$dds
}
sample_order <- droplevels(sample_order)
```

```{r gene_names, include=TRUE}
geneInfoTab <- read_tsv(file.path(analysis$config$rootDir, analysis$config$referenceDir, "geneInfo.tab"), skip = 1, col_names = c("gene_id","gene_symbol","gene_type"))

## Remove samples if there are fewer total fragment counts than there are possible features
## Somewhat arbitrary lower bound and shouldn't be an issue, but could catch a technical error
## if data isn't loading correctly (but you should see this in the mapping plot)
lowcounts <- colSums(assay(analysis$ddsDrop)) < nrow(geneInfoTab)
stopifnot(!sum(lowcounts)>0)
# if (sum(lowcounts)>0){
#   cat("Removing sample(s): ", names(lowcounts)[lowcounts], "due to low counts", sep="\n")
# }
# analysis$ddsDrop <- analysis$ddsDrop[,!lowcounts]
# sample_order <- sample_order[!lowcounts]
# sample_order <- droplevels(sample_order)

rownames(analysis$ddsDrop) <- make.names(geneInfoTab$gene_symbol, unique=TRUE)
rownames(raw_counts) <- make.names(geneInfoTab$gene_symbol, unique=TRUE)
```

```{r vst_and_ddsDrop}
analysis$vst <- varianceStabilizingTransformation(analysis$ddsDrop,
                                                         blind = FALSE,
                                                         fitType = "parametric")
analysis$ddsDrop <- DESeq(analysis$ddsDrop, parallel = TRUE)
```

### Relative Log Expression (RLE) normalization

Library size normalization of read counts with hypothesis that most genes are not differentially expressed

```{r rle}
rawLogCounts <- log(raw_counts[rowMins(raw_counts)>0,])
#log(counts(analysis$ddsDrop)[rowMins(counts(analysis$ddsDrop))>0,])
rawMedianLogs <- rowMedians(rawLogCounts)
rawLogRatios <- rawLogCounts - rawMedianLogs


normLogCounts <- log(DESeq2::counts(analysis$ddsDrop, normalized = TRUE)[rowMins(DESeq2::counts(analysis$ddsDrop))>0,])
normMedianLogs <- rowMedians(normLogCounts)
normLogRatios <- normLogCounts - normMedianLogs

analysis$RLE_raw <- RLE_plot(rawLogRatios, 'RLE Raw')
analysis$RLE_norm <- RLE_plot(normLogRatios, 'RLE Normalized')

print(analysis$RLE_raw)
print(analysis$RLE_norm)
```


### PCA

Exploring projections of expression profiles onto low dimensional space using a limited number of highly variable features. This will give us an estimate of similarity between samples, but will not account for all genes.

```{r pca, fig.width=12, fig.height=8}
analysis$pca <- PCA_plot_from_config(analysis)
print(analysis$pca)
```

```{r write_tables}
dir.create("outputs")
## sample table
write_csv(analysis$sampleTable, path = paste0("outputs/", analysis$config$analysis,".csv"), col_names = TRUE)
## raw counts w/ gene symbols
write_csv(as.data.frame(raw_counts)%>%rownames_to_column(var = "gene_id"),path = paste0("outputs/raw_count_",analysis$config$reference, "_", analysis$config$analysis,".csv"),col_names = TRUE)

## raw counts with ensembl IDs
ensembleRawCount <- do.call(cbind,sapply(analysis$samplefileIDs,
  function(sid){analysis$sampleSTARReads[[sid]][,"unstranded_count"][-c(1:4),]}))
rownames(ensembleRawCount) <- analysis$sampleSTARReads[[1]][-c(1:4),][["gene_id"]]
write_csv(as.data.frame(ensembleRawCount)%>%rownames_to_column(var = "EnsemblID"),
          path = paste0("outputs/raw_count_EnsemblID_", analysis$config$reference, analysis$config$analysis, ".csv"),col_names = TRUE)
## rLog 
analysis$rldDrop <- rlog(analysis$ddsDrop, blind = FALSE, fitType = "parametric")
analysis$assayRlogForGSEA <- assay(analysis$rldDrop)
analysis$assayRlogForGSEA <- analysis$assayRlogForGSEA[rowMeans(analysis$assayRlogForGSEA)>0,]
write_tsv(data.frame(Name = str_remove(rownames(analysis$assayRlogForGSEA), "[.].*"), Description = "na", analysis$assayRlogForGSEA), path = paste0("outputs/rlog_forGSEA_", analysis$config$analysis, ".txt"))

## GSEA cls file
analysis$clsLinesGroup <- c(paste0(c(length(analysis$rldDrop$Group),length(unique(analysis$rldDrop$Group)),1), collapse = " "), paste0(c("#",unique(as.vector(analysis$rldDrop$Group))), collapse = " "), paste0(analysis$rldDrop$Group, collapse = " "))
write_lines(analysis$clsLinesGroup, path = paste0("outputs/Group_",analysis$config$analysis,".cls"))

```

```{r}
saveRDS(analysis, 'analysis_post_QC.Rds')
```

