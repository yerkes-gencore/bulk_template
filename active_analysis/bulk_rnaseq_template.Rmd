---
title: "bulk_RNAseq_Analysis"
author: "DTG"
date: '`r format(file.info("bulk_rnaseq_template.Rmd")$ctime, "%Y-%m-%d")`'
output: 
  rmdformats::robobook:
    fig_width: 9
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo=FALSE, fig.width = 6, fig.height = 4)
library(tidyverse)
library(ggforce)
library(grid)
library(ggpubr)
library(yaml)
library(DESeq2)
library(EDASeq)
library(DT)
library(shiny)
library(EnhancedVolcano)
library(tools)
library(ComplexHeatmap)
library(gridExtra)
library(gtable)
library(circlize)
library(openxlsx)
library(reshape2)
library(kableExtra)
library(rlang)
library(forcats)
library(gtools)
library(RColorBrewer)
library(fgsea)
library(MatrixGenerics)
#library(plyr)

counts <- DESeq2::counts
#config <- yaml.load_file("config.yaml")
source("functions.R")
```

<style type="text/css">
.book .book-body .page-inner {
  max-width: 1600px;
  margin-left: auto;
  margin-right: auto;
}
</style>

## Study overview

```{r reset_analysis_obj, eval=TRUE, include=FALSE}
# This is moved out of the setup block to avoid accidentally overwriting your
# analysis object when restarting a session
analysis = list()
```

```{r load_config, include=FALSE}
# Store config with results object for record keeping
analysis$config <- yaml.load_file("config.yaml")
```

```{r sample_metadata_setup}
## Build your own
analysis$sampleTable <- data.frame(matrix("", 0, 3, dimnames=list(c(), c("FileID", "SampleID", "Group"))), stringsAsFactors=TRUE)

## Or load from file 
analysis$sampleTable <- read.table("exp_design_template.txt", header=T, stringsAsFactors = FALSE)
analysis$sampleTable <- analysis$sampleTable %>% 
  dplyr::arrange(across(all_of(analysis$config$sampleGrouping)))
analysis$sampleTable <- as.data.frame(sapply(analysis$sampleTable, as.factor))

knitr::kable((analysis$sampleTable), position='center', table.attr="style='width:100%;'", format='html') %>%
    kable_styling(full_width = TRUE)

# Store the order you'd like samples to appear in figure
# Order is determined by sampleGrouping parameters in config
# But you could also manually specify it here if there aren't easy rules
sample_order <- fct_inorder(as.character(analysis$sampleTable$SampleID))
```

```{r read_counts_tables, include=FALSE}
analysis$samplefileIDs <- dir(file.path(analysis$config$rootDir, analysis$config$alignmentDir))
analysis$samplefileIDs <- analysis$samplefileIDs[analysis$samplefileIDs %in% analysis$sampleTable$FileID]
analysis$sampleSTARReads <- sapply(analysis$samplefileIDs, function(sid) {read_tsv(paste0(
  dir(file.path(analysis$config$rootDir, analysis$config$alignmentDir), pattern = sid, full.names = TRUE),
  "/",sid,
  analysis$config$STARreadSuffix
), col_names = c("gene_id","unstranded_count","sense_count","antisense_count"),
  col_types = c(gene_id = col_character(),
  unstranded_count = col_double(),
  sense_count = col_double(),
  antisense_count = col_double()))},
simplify = FALSE,
USE.NAMES = TRUE)
```

```{r dds, include=FALSE}
analysis$mapBins <- do.call(cbind,
                            sapply(analysis$sampleTable$FileID, 
          function(sid){analysis$sampleSTARReads[[sid]][,paste0(analysis$config$libraryType,"_count")][c(1:4),]}))
rownames(analysis$mapBins) <- analysis$sampleSTARReads[[1]][c(1:4),][["gene_id"]]
colnames(analysis$mapBins) <- recode(as.character(unlist(strsplit(analysis$sampleTable$SampleID, paste0(".", analysis$config$libraryType, "_count")))), !!!setNames(analysis$sampleTable$SampleID, as.character(analysis$sampleTable$FileID)))
 
raw_counts <- do.call(cbind,sapply(analysis$sampleTable$FileID, function(sid){analysis$sampleSTARReads[[sid]][,paste0( analysis$config$libraryType, "_count")][-c(1:4),]}))
colnames(raw_counts) <- recode(as.character(unlist(strsplit(analysis$sampleTable$FileID, paste0(".", analysis$config$libraryType, "_count")))), !!!setNames(analysis$sampleTable$SampleID, as.character(analysis$sampleTable$FileID)))
rownames(analysis$sampleTable) <- analysis$sampleTable$SampleID
analysis$sampleTable <- analysis$sampleTable[colnames(raw_counts),]
analysis$dds <- DESeqDataSetFromMatrix(raw_counts,
  analysis$sampleTable,
  design = as.formula( ~ 1)
)
analysis$mapBins <- rbind(analysis$mapBins,"N_identified" = colSums2(DESeq2::counts(analysis$dds)))
```

## QC {.tabset}

### Mapping

Mapping outcomes of reads from each sample. Reads need to be 'identified' or successfully mapped to a single feature to be used for gene expression analysis.

```{r mapping_plot}
mapping_plot(analysis$mapBins)
```

```{r remove_samples}
if (!is.null(unlist(analysis$config$dropSamples))){
  out <- paste0("Sample(s)\n", paste0(analysis$config$dropSamples, sep=", ", collapse = ''),"\nbeing removed from downstream analysis per user specification.") 
  analysis$mapBins <- analysis$mapBins[,!colnames(analysis$mapBins) %in% analysis$config$dropSamples]
  analysis$ddsDrop <- analysis$dds[,!(colnames(analysis$dds) %in% analysis$config$dropSamples)]
  sample_order <- sample_order[!(sample_order %in% as.factor(analysis$config$dropSamples))]
  cat(out)
} else {
  analysis$ddsDrop <- analysis$dds
}
sample_order <- droplevels(sample_order)
```

```{r gene_names, include=TRUE}
geneInfoTab <- read_tsv(file.path(analysis$config$rootDir, analysis$config$referenceDir, "geneInfo.tab"), skip = 1, col_names = c("gene_id","gene_symbol","gene_type"))

## Remove samples if there are fewer total fragment counts than there are possible features
## Somewhat arbitrary lower bound and shouldn't be an issue, but could catch a technical error
## if data isn't loading correctly (but you should see this in the mapping plot)
lowcounts <- colSums(assay(analysis$ddsDrop)) < nrow(geneInfoTab)
if (sum(lowcounts)>0){
  cat("Removing sample(s): ", names(lowcounts)[lowcounts], "due to low counts", sep="\n")
}
analysis$ddsDrop <- analysis$ddsDrop[,!lowcounts]
sample_order <- sample_order[!lowcounts]
sample_order <- droplevels(sample_order)

rownames(analysis$ddsDrop) <- make.names(geneInfoTab$gene_symbol, unique=TRUE)
rownames(raw_counts) <- make.names(geneInfoTab$gene_symbol, unique=TRUE)
```

```{r vst_and_ddsDrop}
analysis$vst <- varianceStabilizingTransformation(analysis$ddsDrop,
                                                         blind = FALSE,
                                                         fitType = "parametric")
analysis$ddsDrop <- DESeq(analysis$ddsDrop, parallel = TRUE)
```

### Relative Log Expression (RLE) normalization

```{r rle}
rawLogCounts <- log(raw_counts)[rowMins(raw_counts)>0,])
rawMedianLogs <- rowMedians(rawLogCounts)
rawLogRatios <- rawLogCounts - rawMedianLogs


normLogCounts <- log(DESeq2::counts(analysis$ddsDrop, normalized = TRUE)[rowMins(DESeq2::counts(analysis$ddsDrop))>0,])
normMedianLogs <- rowMedians(normLogCounts)
normLogRatios <- normLogCounts - normMedianLogs

analysis$RLE_raw <- RLE_plot(rawLogRatios, 'RLE Raw')
analysis$RLE_norm <- RLE_plot(normLogRatios, 'RLE Normalized')

print(analysis$RLE_raw)
print(analysis$RLE_norm)
```


### PCA

```{r pca, fig.width=12, fig.height=8}
analysis$pca <- PCA_plot_from_config(analysis)
print(analysis$pca)
```

```{r write_tables}
dir.create("outputs")
write_csv(analysis$sampleTable, path = paste0("outputs/", analysis$config$analysis,".csv"), col_names = TRUE)
write_csv(as.data.frame(raw_counts)%>%rownames_to_column(var = "gene_id"),path = paste0("outputs/raw_count_",analysis$config$reference, "_", analysis$config$analysis,".csv"),col_names = TRUE)

ensembleRawCount <- do.call(cbind,sapply(analysis$samplefileIDs,
                                         function(sid){analysis$sampleSTARReads[[sid]][,"unstranded_count"][-c(1:4),]}))
rownames(ensembleRawCount) <- analysis$sampleSTARReads[[1]][-c(1:4),][["gene_id"]]

write_csv(as.data.frame(ensembleRawCount)%>%rownames_to_column(var = "EnsemblID"),
          path = paste0("outputs/raw_count_EnsemblID_", analysis$config$reference, analysis$config$analysis, ".csv"),col_names = TRUE)
analysis$rldDrop <- rlog(analysis$ddsDrop, blind = FALSE, fitType = "parametric")
analysis$assayRlogForGSEA <- assay(analysis$rldDrop)
# filter low/no-expression genes
analysis$assayRlogForGSEA <- analysis$assayRlogForGSEA[rowMeans(analysis$assayRlogForGSEA)>0,]
write_tsv(data.frame(Name = str_remove(rownames(analysis$assayRlogForGSEA), "[.].*"), Description = "na", analysis$assayRlogForGSEA), path = paste0("outputs/rlog_forGSEA_", analysis$config$analysis, ".txt"))

analysis$clsLinesGroup <- c(paste0(c(length(analysis$rldDrop$Group),length(unique(analysis$rldDrop$Group)),1), collapse = " "), paste0(c("#",unique(as.vector(analysis$rldDrop$Group))), collapse = " "), paste0(analysis$rldDrop$Group, collapse = " "))
write_lines(analysis$clsLinesGroup, path = paste0("outputs/Group_",analysis$config$analysis,".cls"))

```

## DGE {.tabset}

This section of the report analyses gene expression between groups of samples within the study. Changes in gene expression between groups are usually reported on a log2 scale. The significance of a detected change in expression is reported in a raw/nominal p-value and a multiple-testing corrected/adjusted p-value that accounts for the large number of tests conducted in differential gene expression (DGE) and the inherent false positive rate assumed with frequentest p-values.

Each tab has results from a specific comparison within the study. Each tab shows 

1. A summary of significantly differentially expressed genes (DGE)

2. A volcano plot of DGE

3. A table of all significant DGE

4. A dotplot of top GSEA enriched biological pathways

5. A table of top GSEA enriched biological pathways

The order of terms in tab labeling informs how to interpret results. For log-fold change and enrichment, the first listed group is the numerator and the second is the denominator. So in a comparison of X vs Y, a positive log-fold change means the gene is more highly expressed in X, while a negative change means the gene is more highly expressed in Y. enrichment is similar: positive enrichment relates to enrichment in X, and negative enrichment indicates greater enrichment in Y. 

Gene Set Enrichment Analysis (GSEA) is a statistical approach to test systematic changes in groups of genes corresponding to biological pathways. A pathway is generally 'enriched' in one study group if the genes in that pathway are systematically up or down regulated in a manner and magnitude that is unlikely to be due to chance. Read more about GSEA [here](https://www.gsea-msigdb.org/gsea/index.jsp)

```{r GSEA_setup}
## read in rlog file
rlog_for_GSEA <- read.csv(paste0("outputs/rlog_forGSEA_", analysis$config$analysis, ".txt"), sep='\t')
## read GMT files
gmt.file <- list()
  for (a in file.path(analysis$config$rootDir, analysis$config$gseaFilesPath, analysis$config$gseaCollections)){#'mh.all.v0.3.symbols.gmt'
    gmt.file <- append(gmt.file, gmtPathways(file.path(a)))
  }
```

```{r run_comparisons}

### Add comparisons as you would pass them to a DESeq2::results contrast perameter E.g., 
### if you want a single existing contrast, pass it in as a string
### if you want to make a new contrast between factors, make it a list within the list

# resultsNames(analysis$ddsDrop)

  
my_comparisons <- list('GroupsamRNA.TimeD1', 
                       'GroupsamRNA.TimeD2',
                       list(c('Time_D1_vs_D0', 'GroupsamRNA.TimeD1')),
                       list(c('Time_D2_vs_D0', 'GroupsamRNA.TimeD2')),
                       list(c('Time_D7_vs_D0', 'GroupsamRNA.TimeD7')),
                       'Time_D1_vs_D0',
                       'Time_D2_vs_D0',
                       'Time_D4_vs_D0',
                       'Time_D7_vs_D0')

## groups to include for greg's filter function, specific to each comparison
filter_on_list <- list('D1',
                       'D2',
                       c('D1', 'D0'),
                       c('D2', 'D0'),
                       c('D7', 'D0'),
                       c('D1', 'D0'),
                       c('D2', 'D0'),
                       c('D4', 'D0'),
                       c('D7', 'D0'))

# pairwise_comparisons <- function(x, alpha=0.05){
#   ## Generate DESeq2 results objects for contrasts of interest
#   result <- results(analysis$ddsDrop, contrast=x, test='Wald', alpha=alpha)
#   result@metadata$contrast <- paste0(x, collapse='_')
#   return(result)
# }


pairwise_comparisons <- function(x, filt_groups,alpha=0.05){
  ## Generate DESeq2 results objects for contrasts of interest
  if (class(x) == 'list'){
    result <- results(analysis$ddsDrop, contrast=x, test='Wald', alpha=alpha,
                      filter = maxMinFilter(analysis$ddsDrop,                                                                                intgroup = 'Time',                                                                                  comp = filt_groups))
  } else if (class(x) == 'character'){
    result <- results(analysis$ddsDrop, name=x, test='Wald', alpha=alpha,
                      filter = maxMinFilter(analysis$ddsDrop,                                                                                intgroup = 'Time',                                                                                  comp = filt_groups))
  }
  result@metadata$contrast <- paste0(x, collapse='_')
  return(result)
}

## Get DESeq2 results for each comparison of interest
results <- mapply(pairwise_comparisons,my_comparisons, filter_on_list)
wb <- createWorkbook()
## Convert these result objects to custom class with visualizations, etc
## option to write out each result as an individual sheet in the workbook
results <- lapply(results, my_results_transform, wb, write_out=TRUE)

## Name result objects from contrasts
names(results) <- lapply(results, function(x) x@metadata$contrast)


## Write all results to workbook 
write_output_workbook(wb, results, analysis)
saveWorkbook(wb, file=paste0(analysis$config$analysis, "_DESeq2_results.xlsx"), overwrite=T)
```

```{r prepare_results}
### you can add custom ggplot tracks to the outputs here, or edit datatables
### Input is the modifided DESeq2 object with the visualizations
output_results <- function(comp){
  # Just plaintext summary of the result object
  summary(results[[comp]])
  # Fixed window volcano plot
  volcanoPlot <- results[[comp]]@visualizations$volplot_fixed + labs(caption='Fixed window volcano plot, for comparing global trends across comparisons.')
  # Interactive datatable of all DGE results for this comp
  DGEtable <- DT::datatable(data.frame(results[[comp]]) %>% select(baseMean, log2FoldChange, lfcSE, padj) %>% filter(padj < analysis$config$alpha) %>% mutate_if(is.numeric, round, 4) %>% na.omit() %>% rownames_to_column(), rownames = FALSE, caption='DESeq2 output for this comparison, significant genes only', filter='top', autoHideNavigation = TRUE) 
  # Dotplot of top GSEA pathways
  gseaDotplot <- gsea_dotplot(results[[comp]]@gsea)
  # Interactive table of GSEA results
  gseaTable <- DT::datatable(head(results[[comp]]@gsea[order(results[[comp]]@gsea$pval)] %>% filter(size>10),100) %>% select(pathway,pval,padj,ES,NES,size,), rownames = FALSE, filter='top', autoHideNavigation = TRUE, caption='GSEA enrichment results, top 100') %>% formatRound(c('pval','padj', 'ES','NES'), digits=3)
  
  return(list(volcanoPlot=volcanoPlot,DGEtable=DGEtable,gseaDotplot=gseaDotplot,gseaTable=gseaTable))
}
```

### Comparison 1

```{r}
### call results outputs here with output_results(name_of_comparison)
### comparison names are based on the input lists earlier
comparison1 <- output_results(my_comparisons[[1]][[1]])
```

```{r, fig.height=8}
## kept separate to allow modified figure size
comparison1$volcanoPlot
```

```{r}
comparison1$DGEtable
```

```{r, fig.height=10}
comparison1$gseaDotplot
```

```{r}
comparison1$gseaTable
```

### Comparison 2 {.active}
<!-- You can make this the active tab instead of the first one if you want to highlight certain comp -->
```{r}
## Same as before with the next comparison. Repeat for however many comparisons you have
comparison2 <- output_results( my_comparisons[[1]][[2]])
```

```{r, fig.height=8}
comparison2$volcanoPlot
```

```{r}
comparison2$DGEtable
```

```{r, fig.height=10}
comparison2$gseaDotplot
```

```{r}
comparison2$gseaTable
```

## Genes of interest {.tabset}

These heatmaps show the relative expression (regularized and log2 transformed) of genes for each sample normalized to the baseline (mean expression for pre-treatment samples). Individual samples are grouped within their treatment/timepoint. If you have genes you are interested in seeing from your study, we can plot them here.

### Top genes from whole study

```{r, fig.width = 10, fig.height=5}
## creating an arbitrary genelist
top_genes <- data.frame(results(analysis$ddsDrop)) %>% filter(!is.na(pvalue)) %>% filter(abs(log2FoldChange)>log2(1.5))
top_genes <- top_genes[order(top_genes$pvalue),]
geneList <- (rownames(head(top_genes, 20)))

## Pass in a genelist
heatmap_from_genelist(geneList)
```

## GSEA {.tabset}


Top GSEA pathways from this study. If you have specific biological pathways you want to see, you can request them to be plotted here. 

```{r}
A.fix <- rlog_for_GSEA %>% filter(duplicated(Name) | duplicated(Name, fromLast=TRUE)) %>% mutate(Description = rowSums(select(.,-c(Name, Description)))) %>% arrange(Name, -Description) %>% distinct(Name, .keep_all = TRUE) 
A <- rbind(A.fix, rlog_for_GSEA) %>% select(-Description) %>% distinct(Name, .keep_all = TRUE) %>% column_to_rownames('Name') %>% data.matrix()
gene.labels <- rownames(A)
sample.names <- colnames(A)
CLS <- GSEA.ReadClsFile(file = 'outputs/Group_p22074_Peijian_Analysis.cls')
class.labels <- CLS$class.v
class.phen <- CLS$phen
col.index <- order(class.labels, decreasing = F)
A <- A[,col.index]
class.labels <- class.labels[col.index]
sample.names <- sample.names[col.index]
sample.phen <- factor(class.labels, unique(class.labels), labels=class.phen)
```


```{r}
comp.num <-  'FAC'
comp.denom <- 'Cont'
#sample.names[sample.phen=='FAC']
comp.ind <- c(grep(paste0('^',comp.num,'$'), sample.phen), grep(paste0('^',comp.denom,'$'), sample.phen))#sample.phen %in% comparison

  
  
O <- GSEA.GeneRanking(A[,comp.ind], class.labels[comp.ind], gene.labels, nperm = 1, permutation.type = 0, 
    sigma.correction = "GeneCluster", fraction = 1, replace = FALSE, 
    reverse.sign = FALSE, rank.metric = "S2N")
# order.matrix[, n.starts[nk]:n.ends[nk]] <- O$order.matrix
# obs.order.matrix[, n.starts[nk]:n.ends[nk]] <- O$obs.order.matrix
# correl.matrix[, n.starts[nk]:n.ends[nk]] <- O$rnk.matrix
# obs.correl.matrix[, n.starts[nk]:n.ends[nk]] <- O$obs.rnk.matrix
ranks <- O$obs.rnk.matrix[O$obs.order.matrix,]
```

```{r}
res <- fgseaSimple(pathways=gmt.file,
                   stats=ranks,
                   nperm=1000)
```

