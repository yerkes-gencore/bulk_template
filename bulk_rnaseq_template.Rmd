---
title: "bulk_RNAseq_Analysis"
author: "DTG"
date: '`r format(file.info("bulk_rnaseq_template.Rmd")$ctime, "%Y-%m-%d")`'
output: 
  rmdformats::robobook:
    fig_width: 9
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo=FALSE, fig.width = 6, fig.height = 4)
library(tidyverse)
library(ggforce)
library(grid)
library(ggpubr)
library(yaml)
library(DESeq2)
library(EDASeq)
library(DT)
library(shiny)
library(EnhancedVolcano)
library(tools)
library(ComplexHeatmap)
library(gridExtra)
library(gtable)
library(circlize)
library(openxlsx)
library(reshape2)
library(kableExtra)
library(rlang)
library(forcats)
library(gtools)
library(RColorBrewer)
library(fgsea)
library(MatrixGenerics)
#library(plyr)

counts <- DESeq2::counts
#config <- yaml.load_file("config.yaml")
source("functions.R")
```

<style type="text/css">
.book .book-body .page-inner {
  max-width: 1600px;
  margin-left: auto;
  margin-right: auto;
}
</style>

## Study overview

```{r reset_analysis_obj, eval=TRUE, include=FALSE}
# This is moved out of the setup block to avoid accidentally overwriting your
# analysis object when restarting a session
analysis = list()
```

```{r load_config, include=FALSE}
# Store config with results object for record keeping
analysis$config <- yaml.load_file("config.yaml")
```

```{r sample_metadata_setup}
## Build your own
analysis$sampleTable <- data.frame(matrix("", 0, 3, dimnames=list(c(), c("FileID", "SampleID", "Group"))), stringsAsFactors=TRUE)

## Or load from file 
analysis$sampleTable <- read.table("exp_design_template.txt", header=T, stringsAsFactors = FALSE)
analysis$sampleTable <- analysis$sampleTable %>% 
  dplyr::arrange(across(all_of(analysis$config$sampleGrouping)))
analysis$sampleTable <- as.data.frame(sapply(analysis$sampleTable, as.factor))

knitr::kable((analysis$sampleTable), position='center', table.attr="style='width:100%;'", format='html') %>%
    kable_styling(full_width = TRUE)

# Store the order you'd like samples to appear in figure
# Order is determined by sampleGrouping parameters in config
# But you could also manually specify it here if there aren't easy rules
sample_order <- fct_inorder(as.character(analysis$sampleTable$SampleID))
```

```{r read_counts_tables, include=FALSE}
analysis$samplefileIDs <- dir(file.path(config$rootDir, config$alignmentDir))
analysis$samplefileIDs <- analysis$samplefileIDs[analysis$samplefileIDs %in% analysis$sampleTable$FileID]
analysis$sampleSTARReads <- sapply(analysis$samplefileIDs, function(sid) {read_tsv(paste0(
  dir(file.path(config$rootDir, config$alignmentDir), pattern = sid, full.names = TRUE),
  "/",sid,
  config$STARreadSuffix
), col_names = c("gene_id","unstranded_count","sense_count","antisense_count"),
  col_types = c(gene_id = col_character(),
  unstranded_count = col_double(),
  sense_count = col_double(),
  antisense_count = col_double()))},
simplify = FALSE,
USE.NAMES = TRUE)
```

```{r dds, include=FALSE}
analysis$mapBins <- do.call(cbind,
                            sapply(analysis$samplefileIDs, 
          function(sid){analysis$sampleSTARReads[[sid]][,"unstranded_count"][c(1:4),]}))
rownames(analysis$mapBins) <- analysis$sampleSTARReads[[1]][c(1:4),][["gene_id"]]
colnames(analysis$mapBins) <- recode(as.character(unlist(strsplit(analysis$samplefileIDs, ".unstranded_count"))), !!!setNames(analysis$sampleTable$SampleID, as.character(analysis$sampleTable$FileID)))
 
raw_counts <- do.call(cbind,sapply(analysis$samplefileIDs, function(sid){analysis$sampleSTARReads[[sid]][,"unstranded_count"][-c(1:4),]}))
colnames(raw_counts) <- recode(as.character(unlist(strsplit(analysis$samplefileIDs, ".unstranded_count"))), !!!setNames(analysis$sampleTable$SampleID, as.character(analysis$sampleTable$FileID)))
rownames(analysis$sampleTable) <- analysis$sampleTable$SampleID
analysis$sampleTable <- analysis$sampleTable[colnames(raw_counts),]
analysis$dds <- DESeqDataSetFromMatrix(raw_counts,
  analysis$sampleTable,
  design = as.formula(paste0("~ ", analysis$config$design))
)
analysis$mapBins <- rbind(analysis$mapBins,"N_identified" = colSums2(DESeq2::counts(analysis$dds)))
```

## QC {.tabset}

### Mapping

Mapping outcomes of reads from each sample. Reads need to be 'identified' or successfully mapped to a single feature to be used for gene expression analysis.

```{r mapping_plot}
mapping_plot(analysis$mapBins)
```

```{r remove_samples}
if (!is.null(unlist(analysis$config$dropSamples))){
  out <- paste0("Sample(s)\n", paste0(analysis$config$dropSamples, sep=", ", collapse = ''),"\nbeing removed from downstream analysis per user specification.") 
  analysis$mapBins <- analysis$mapBins[,!colnames(analysis$mapBins) %in% analysis$config$dropSamples]
  analysis$ddsDrop <- analysis$dds[,!(colnames(analysis$dds) %in% analysis$config$dropSamples)]
  sample_order <- sample_order[!(sample_order %in% as.factor(analysis$config$dropSamples))]
  cat(out)
} else {
  analysis$ddsDrop <- analysis$dds
}
sample_order <- droplevels(sample_order)
```

```{r gene_names, include=FALSE}
geneInfoTab <- read_tsv(file.path(analysis$config$rootDir, analysis$config$referenceDir, "geneInfo.tab"), skip = 1, col_names = c("gene_id","gene_symbol","gene_type"))

## Remove samples if there are fewer total fragment counts than there are possible features
## Somewhat arbitrary lower bound and shouldn't be an issue, but could catch a technical error
## if data isn't loading correctly (but you should see this in the mapping plot)
lowcounts <- colSums(assay(analysis$ddsDrop)) < nrow(geneInfoTab)
if (sum(lowcounts)>0){
  cat("Removing sample(s): ", names(lowcounts)[lowcounts], "due to low counts", sep="\n")
}
analysis$ddsDrop <- analysis$ddsDrop[,!lowcounts]
sample_order <- sample_order[!lowcounts]
sample_order <- droplevels(sample_order)

rownames(analysis$ddsDrop) <- make.names(geneInfoTab$gene_symbol, unique=TRUE)
rownames(raw_counts) <- make.names(geneInfoTab$gene_symbol, unique=TRUE)
```

```{r vst_and_ddsDrop}
analysis$vst <- varianceStabilizingTransformation(analysis$ddsDrop,
                                                         blind = FALSE,
                                                         fitType = "parametric")
analysis$ddsDrop <- DESeq(analysis$ddsDrop, parallel = TRUE)
```

### Relative Log Expression (RLE) normalization

```{r rle}
rawLogCounts <- log(counts(analysis$ddsDrop)[rowMins(counts(analysis$ddsDrop))>0,])
rawMedianLogs <- rowMedians(rawLogCounts)
rawLogRatios <- rawLogCounts - rawMedianLogs


normLogCounts <- log(DESeq2::counts(analysis$ddsDrop, normalized = TRUE)[rowMins(DESeq2::counts(analysis$ddsDrop))>0,])
normMedianLogs <- rowMedians(normLogCounts)
normLogRatios <- normLogCounts - normMedianLogs

analysis$RLE_raw <- RLE_plot(rawLogRatios, 'RLE Raw')
analysis$RLE_norm <- RLE_plot(normLogRatios, 'RLE Normalized')

print(analysis$RLE_raw)
print(analysis$RLE_norm)
```


### PCA

```{r pca, fig.width=12, fig.height=8}
analysis$pca <- PCA_plot_from_config(analysis)
print(analysis$pca)
```

```{r write_tables}
write_csv(analysis$sampleTable, path = paste0(analysis$config$analysis,".csv"), col_names = TRUE)
write_csv(as.data.frame(raw_counts)%>%rownames_to_column(var = "gene_id"),path = paste0("raw_count_",analysis$config$reference, "_", analysis$config$analysis,".csv"),col_names = TRUE)

ensembleRawCount <- do.call(cbind,sapply(analysis$samplefileIDs,
                                         function(sid){analysis$sampleSTARReads[[sid]][,"unstranded_count"][-c(1:4),]}))
rownames(ensembleRawCount) <- analysis$sampleSTARReads[[1]][-c(1:4),][["gene_id"]]

write_csv(as.data.frame(ensembleRawCount)%>%rownames_to_column(var = "EnsemblID"),
          path = paste0("raw_count_EnsemblID_", analysis$config$reference, analysis$config$analysis, ".csv"),col_names = TRUE)
analysis$rldDrop <- rlog(analysis$ddsDrop, blind = FALSE, fitType = "parametric")
analysis$assayRlogForGSEA <- assay(analysis$rldDrop)
# filter low/no-expression genes
analysis$assayRlogForGSEA <- analysis$assayRlogForGSEA[rowMeans(analysis$assayRlogForGSEA)>0,]
write_tsv(data.frame(Name = str_remove(rownames(analysis$assayRlogForGSEA), "[.].*"), Description = "na", analysis$assayRlogForGSEA), path = paste0("rlog_forGSEA_", analysis$config$analysis, ".txt"))
analysis$clsLinesGroup <- c(paste0(c(length(analysis$rldDrop$Group),length(unique(analysis$rldDrop$Group)),1), collapse = " "), paste0(c("#",unique(as.vector(analysis$rldDrop$Group))), collapse = " "), paste0(analysis$rldDrop$Group, collapse = " "))
write_lines(analysis$clsLinesGroup, path = paste0("Group_",analysis$config$analysis,".cls"))

```

## DGE {.tabset}

```{r GSEA_setup}
## read in rlog file
rlog_for_GSEA <- read.csv(paste0("rlog_forGSEA_", analysis$config$analysis, ".txt"), sep='\t')
## read GMT files
gmt.file <- list()
  for (a in file.path(analysis$config$rootDir, analysis$config$gseaFilesPath, analysis$config$gseaCollections)){#'mh.all.v0.3.symbols.gmt'
    gmt.file <- append(gmt.file, gmtPathways(file.path(a)))
  }
```

```{r run_comparisons}

#### Add comparisons to get results for here as list of two lists: 
#### first list has the result names for coefficients to compare
#### second is a list that maps to the first list and says whether to run it as
#### results(analysis, name=<comparison>) or results(analysis, contrast=c(list(<comparisons)))
#### these can be very different and are important for multifactor designs
#### See example below. First list is the names/contrasts. If it is a contrast,
#### the two factors should be put as a list. A name can just be a character vector
####  my_comparisons <- list(                           # the whole thing is a list of lists
####            list('CD8Depleted.TimepointW1',         # the list of comparisons
####                  list('Timepoint_W7_vs_W0',        # the second member is a contrast, so a list of two names
####                       'CD8Depleted.TimepointW7'),
####                       'Timepoint_W1_vs_W0'),       # end of comparisons
####                  list('name', 'contrast', 'name')) # second list, saying if each member of the first 
####                                                    # list is a name or a contrast for the results call

my_comparisons <- list(list('Group_FAC_vs_Cont', 'Group_LiproxposFAC_vs_Cont', 'Group_MTposFAC_vs_Cont'),
                       list('name', 'name', 'name'))

pairwise_comparisons <- function(x, comp, alpha=0.05){
  ## Generate DESeq2 results objects for contrasts of interest
  if (comp == 'contrast'){
    result <- results(analysis$ddsDrop, contrast=x, test='Wald', alpha=alpha)
  } else if (comp == 'name'){
    result <- results(analysis$ddsDrop, name=x, test='Wald', alpha=alpha)
  }
  result@metadata$contrast <- paste0(x, collapse=' ')
  return(result)
}

## Get DESeq2 results for each comparison of interest
results <- mapply(pairwise_comparisons,my_comparisons[[1]], my_comparisons[[2]])
wb <- createWorkbook()
## Convert these result objects to custom class with visualizations, etc
## option to write out each result as an individual sheet in the workbook
results <- lapply(results, my_results_transform, wb, write_out=TRUE)

## Name result objects from contrasts
names(results) <- lapply(results, function(x) x@metadata$contrast)


## Write all results to workbook 
write_output_workbook(wb, results, analysis)
saveWorkbook(wb, file=paste0(analysis$config$analysis, "_DESeq2_results.xlsx"), overwrite=T)
```

```{r prepare_results}
### you can add custom ggplot tracks to the outputs here, or edit datatables
### Input is the modifided DESeq2 object with the visualizations
output_results <- function(comp){
  # Just plaintext summary of the result object
  summary(results[[comp]])
  # Fixed window volcano plot
  volcanoPlot <- results[[comp]]@visualizations$volplot_fixed + labs(caption='Fixed window volcano plot, for comparing global trends across comparisons.')
  # Interactive datatable of all DGE results for this comp
  DGEtable <- DT::datatable(data.frame(results[[comp]]) %>% select(baseMean, log2FoldChange, lfcSE, padj) %>% filter(padj < analysis$config$alpha) %>% mutate_if(is.numeric, round, 4) %>% na.omit() %>% rownames_to_column(), rownames = FALSE, caption='DESeq2 output for this comparison, significant genes only', filter='top', autoHideNavigation = TRUE) 
  # Dotplot of top GSEA pathways
  gseaDotplot <- gsea_dotplot(results[[comp]]@gsea)
  # Interactive table of GSEA results
  gseaTable <- DT::datatable(head(results[[comp]]@gsea[order(results[[comp]]@gsea$pval)] %>% filter(size>10),1000) %>% select(pathway,pval,padj,ES,NES,size,), rownames = FALSE, filter='top', autoHideNavigation = TRUE, caption='GSEA enrichment results, top 1000') %>% formatRound(c('pval','padj', 'ES','NES'), digits=3)
  
  return(list(volcanoPlot=volcanoPlot,DGEtable=DGEtable,gseaDotplot=gseaDotplot,gseaTable=gseaTable))
}
```

### Comparison 1

```{r}
### call results outputs here with output_results(name_of_comparison)
### comparison names are based on the input lists earlier
comparison1 <- output_results(my_comparisons[[1]][[1]])
```

```{r, fig.height=8}
## kept separate to allow modified figure size
comparison1$volcanoPlot
```

```{r}
comparison1$DGEtable
```

```{r, fig.height=10}
comparison1$gseaDotplot
```

```{r}
comparison1$gseaTable
```

### Comparison 2 {.active}
<!-- You can make this the active tab instead of the first one if you want to highlight certain comp -->
```{r}
## Same as before with the next comparison. Repeat for however many comparisons you have
comparison2 <- output_results( my_comparisons[[1]][[2]])
```

```{r, fig.height=8}
comparison2$volcanoPlot
```

```{r}
comparison2$DGEtable
```

```{r, fig.height=10}
comparison2$gseaDotplot
```

```{r}
comparison2$gseaTable
```

## Genes of interest {.tabset}

These heatmaps show the relative expression (regularized and log2 transformed) of genes for each sample normalized to the baseline (mean expression for pre-treatment samples). Individual samples are grouped within their treatment/timepoint. Below the heatmaps are line plots of the same genes, tracking changes in normalized expression over time.

### Top genes from whole study

```{r, fig.width = 10, fig.height=5}
## creating an arbitrary genelist
top_genes <- data.frame(results(analysis$ddsDrop)) %>% filter(!is.na(pvalue)) %>% filter(abs(log2FoldChange)>log2(1.5))
top_genes <- top_genes[order(top_genes$pvalue),]
geneList <- (rownames(head(top_genes, 20)))

## Pass in a genelist
heatmap_from_genelist(geneList)
```
