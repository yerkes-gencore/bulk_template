---
title: "model_validation"
author: "ENPRC Gencore"
date:  "`r Sys.Date()`"
output: 
  rmdformats::robobook:
    fig_width: 9
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE,
                      message = FALSE, 
                      echo=FALSE,
                      fig.width = 6,
                      fig.height = 4,
                      dev='png')
library(tidyverse)    ## General logic and processing
# library(DESeq2)       ## Makes us have a job
library(here)         ## For consistent directory structures
library(edgeR)
library(DT)
library(reshape2)
library(gencoreBulk)
```

# Read metadata

```{r}
obj <- readRDS('/yerkes-cifs/runs/analyst/micah/Analysis/2023_Analyses/p23224_Matthew//p23224_Matthew_Analysis/rds/report-01/bulk-p23224_Matthew-no_design_yet.rds')
metadata <- as.data.frame(obj$md$sampleTable)
exp_data <- obj$dge
plots <- list()
```

```{r}
metadata %>%
  select(-c(FileID, SampleID, grp.day, readPath))
  # select(sampleID, SubjectID, grp)
```

```{r}
relevant_cols <- colnames(metadata %>% select(-c(FileID, SampleID, grp.day, readPath, sampleID)))
metadata_summary <- lapply(relevant_cols, function(x) table(unlist((metadata[[x]]))))
names(metadata_summary) <- relevant_cols
metadata_summary
```

```{r}
table(metadata$SubjectID, metadata$grp)
```

```{r}
table(metadata$SubjectID, metadata$day)
```

```{r}
table(metadata$response, metadata$grp)
```

```{r}
table(metadata$response, metadata$SubjectID)
```

# Set levels

```{r}
metadata$day <- factor(metadata$day, levels = c('P14', 'D00', 'D03', 'D07', 'D28'))
metadata$grp <- factor(metadata$grp, levels = c('grp2', 'grp3'))
```


# Design

```{r}
design_formula <- as.formula('~ day + grp + grp:day')
design_matrix  <- stats::model.matrix(design_formula, data = metadata)
colnames(design_matrix)
```

## Fit design

```{r}
model_fit <- edgeR::voomLmFit(counts = obj$dge,
                              design = design_matrix,
                              block = metadata$SubjectID,
                              sample.weights = TRUE)
```

# Define contrasts

Explicitly write out full contrast formulas, including terms that will cancel and
expanded interaction terms.
This avoids mistakes and facilitates plotting.

You do not have to use valid R names at this stage, as that will be corrected
for later. Just use the colnames of the design matrix.

```{r}
colnames(design_matrix)
```


```{r}
contrast_matrix_expanded <- data.frame(
  contrast_names = c(
    'P14_grp3vgrp2',
    'D00_grp3vgrp2',
    'D03_grp3vgrp2',
    'D07_grp3vgrp2',
    'D28_grp3vgrp2',
    'grp3vgrp2_D00vP14'
  ),
  numerators = c(
    '(Intercept)',
    '(Intercept) + dayD00 + grpgrp3 + dayD00:grpgrp3',
    '(Intercept) + dayD03 + grpgrp3 + dayD03:grpgrp3',
    '(Intercept) + dayD07 + grpgrp3 + dayD07:grpgrp3',
    '(Intercept) + dayD28 + grpgrp3 + dayD28:grpgrp3',
    '(Intercept) + grpgrp3 + dayD00:grpgrp3'
  ),
  denominators = c(
    '(Intercept)',
    '(Intercept) + dayD00',
    '(Intercept) + dayD03',
    '(Intercept) + dayD07',
    '(Intercept) + dayD28',
    '(Intercept) + grpgrp3'
  )
)
contrast_matrix_expanded
```

```{r}
## have to make valid names first
contrast_matrix <- contrast_matrix_expanded
contrast_matrix$denominators <-
  sapply(contrast_matrix$denominators, function(x) {
    paste(make.names(unlist(strsplit(x, perl = TRUE, split = '\\s*\\+\\s*'))), collapse = ' + ')
  })
contrast_matrix$numerators <-
  sapply(contrast_matrix$numerators, function(x) {
    paste(make.names(unlist(strsplit(x, perl = TRUE, split = '\\s*\\+\\s*'))), collapse = ' + ')
  })

## Then make contrasts
contrast_matrix <- apply(contrast_matrix, MARGIN = 1, function(row) {
  paste0('(', row[2], ') - (', row[3], ')')
})
contrast_matrix <- limma::makeContrasts(contrasts = contrast_matrix,
    levels = make.names(colnames(design_matrix)))
colnames(contrast_matrix) <- contrast_matrix_expanded$contrast_names
contrast_matrix
```

# Extract contrasts

```{r}
## Re-orient the fitted model object from the coefficients of the original design matrix to the set of contrasts defined above in contr.matrix
extracted_contrasts <- contrasts.fit(model_fit, contrasts = contrast_matrix)
  ## Run empirical Bayes moderation; borrowing information across all the genes to obtain more precise estimates of gene-wise variability
extracted_contrasts <- eBayes(extracted_contrasts, robust=TRUE)
  ## Plot the model's residual variances against average expression values; demonstrating that the variance is no longer dependent on the mean expression level
plotSA(extracted_contrasts, main="Final model: Mean-variance trend")
  ## Identify which genes are significantly differentially expressed for each contrast from a fit object containing p-values and test statistics
extracted_contrasts$sig <- decideTests(extracted_contrasts, lfc = 0)
```

```{r}
createResTables <- function(obj) {
  resultsTables <- list()
  for (contrast in colnames(obj$contrasts)) {
    resultsTables[[contrast]] <- topTable(obj, coef = contrast, n = Inf) %>%
      # as_tibble(rownames = "gene") %>%
      dplyr::rename(log2FoldChange = logFC, pvalue = P.Value, padj = adj.P.Val)
  }
  return(resultsTables)
}

# Arrange by cluster, then by contrast
resTables <- createResTables(extracted_contrasts)

# Put all the results in a single table
resTable_AllOneTbl <- lapply(resTables, function(one_tbl) {
    one_tbl %>%
    rownames_to_column(var = "gene")
  }) %>% bind_rows(., .id = "contrast")
```

# Results table

```{r}
resTable_AllOneTbl
```

# Visualize coefficients

Plot expression boxplots for quick inspections

```{r}
plotGeneExpression('JUN',
                   counts =  model_fit$EList$E,
                   metadata = model_fit$targets,
                   grouping = 'grp.day',
                   subsetting = 'day',
                   subsets = 'D00') 
```

You can try to add coefficient terms too to see if they track with your expectations

```{r}
plotGeneExpression(gene = 'JUN', 
               counts = model_fit$EList$E,
               metadata = model_fit$targets,
               grouping = 'grp',
               subsetting = 'day', subsets = 'D28') +
   plotModelCoeffs(gene = 'JUN', expr = contrast_matrix_expanded[5,2] , coefficients = model_fit$coefficients)  
## Or you can return the data for manual plotting
arrow_coords <- plotModelCoeffs(gene = 'JUN', expr = contrast_matrix_expanded[5,2] , coefficients = model_fit$coefficients, data_only = TRUE)  
## Can edit values here if desired, such as X coordinates
## arrow_coords$x = 0.5

plotGeneExpression(gene = 'JUN', 
               counts = model_fit$EList$E,
               metadata = model_fit$targets,
               grouping = 'grp',
               subsetting = 'day', subsets = 'D28') +
  ## Then manually create the arrows
   ggplot2::geom_segment(data = arrow_coords, 
                        aes(x = x,
                            xend = x,
                            y = y, 
                            yend = yend,
                            color = terms),
                        arrow = ggplot2::arrow()) 
```

