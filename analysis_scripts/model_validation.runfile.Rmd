---
title: "model_validation"
author: "ENPRC Gencore"
date:  "`r Sys.Date()`"
output: 
  rmdformats::robobook:
    fig_width: 9
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE,
                      message = FALSE, 
                      echo=FALSE,
                      fig.width = 6,
                      fig.height = 4,
                      dev='png')
library(tidyverse)    ## General logic and processing
# library(DESeq2)       ## Makes us have a job
library(here)         ## For consistent directory structures
library(edgeR)
library(DT)
library(reshape2)
library(gencoreBulk)
```

# Read metadata

```{r}
obj <- readRDS('/yerkes-cifs/runs/analyst/micah/Analysis/2023_Analyses/p23224_Matthew//p23224_Matthew_Analysis/rds/report-01/bulk-p23224_Matthew-no_design_yet.rds')
metadata <- as.data.frame(obj$md$sampleTable)
exp_data <- obj$dge
plots <- list()
```

```{r}
metadata %>%
  select(-c(FileID, SampleID, grp.day, readPath))
  # select(sampleID, SubjectID, grp)
```

```{r}
relevant_cols <- colnames(metadata %>% select(-c(FileID, SampleID, grp.day, readPath, sampleID)))
metadata_summary <- lapply(relevant_cols, function(x) table(unlist((metadata[[x]]))))
names(metadata_summary) <- relevant_cols
metadata_summary
```

```{r}
table(metadata$SubjectID, metadata$grp)
```

```{r}
table(metadata$SubjectID, metadata$day)
```

```{r}
table(metadata$response, metadata$grp)
```

```{r}
table(metadata$response, metadata$SubjectID)
```

# Set levels

```{r}
metadata$day <- factor(metadata$day, levels = c('P14', 'D00', 'D03', 'D07', 'D28'))
metadata$grp <- factor(metadata$grp, levels = c('grp2', 'grp3'))
```


# Design

```{r}
design_formula <- as.formula('~ day + grp + grp:day')
design_matrix  <- stats::model.matrix(design_formula, data = metadata)
colnames(design_matrix)
```

## Fit design

```{r}
model_fit <- edgeR::voomLmFit(counts = obj$dge,
                              design = design_matrix,
                              block = metadata$SubjectID,
                              sample.weights = TRUE)
```

# Define contrasts

Explicitly write out full contrast formulas, including terms that will cancel and
expanded interaction terms.
This avoids mistakes and facilitates plotting.

You do not have to use valid R names at this stage, as that will be corrected
for later. Just use the colnames of the design matrix.

```{r}
colnames(design_matrix)
```


```{r}
contrast_matrix_expanded <- data.frame(
  contrast_names = c(
    'P14_grp3vgrp2',
    'D00_grp3vgrp2',
    'D03_grp3vgrp2',
    'D07_grp3vgrp2',
    'D28_grp3vgrp2'
  ),
  numerators = c(
    '(Intercept) + grpgrp3',
    '(Intercept) + grpgrp3 + dayD00 + dayD00:grpgrp3',
    '(Intercept) + grpgrp3 + dayD03 + dayD03:grpgrp3',
    '(Intercept) + grpgrp3 + dayD07 + dayD07:grpgrp3',
    '(Intercept) + grpgrp3 + dayD28 + dayD28:grpgrp3'
  ),
  denominators = c(
    '(Intercept)',
    '(Intercept) + dayD00',
    '(Intercept) + dayD03',
    '(Intercept) + dayD07',
    '(Intercept) + dayD28'
  )
)
contrast_matrix_expanded
```

```{r}
## have to make valid names first
contrast_matrix <- contrast_matrix_expanded
contrast_matrix$denominators <-
  sapply(contrast_matrix$denominators, function(x) {
    paste(make.names(unlist(strsplit(x, perl = TRUE, split = '\\s*\\+\\s*'))), collapse = ' + ')
  })
contrast_matrix$numerators <-
  sapply(contrast_matrix$numerators, function(x) {
    paste(make.names(unlist(strsplit(x, perl = TRUE, split = '\\s*\\+\\s*'))), collapse = ' + ')
  })

## Then make contrasts
contrast_matrix <- apply(contrast_matrix, MARGIN = 1, function(row) {
  paste0('(', row[2], ') - (', row[3], ')')
})
contrast_matrix <- limma::makeContrasts(contrasts = contrast_matrix,
    levels = make.names(colnames(design_matrix)))
colnames(contrast_matrix) <- contrast_matrix_expanded$contrast_names
contrast_matrix
```

# Extract contrasts

```{r}
## Re-orient the fitted model object from the coefficients of the original design matrix to the set of contrasts defined above in contr.matrix
extracted_contrasts <- contrasts.fit(model_fit, contrasts = contrast_matrix)
  ## Run empirical Bayes moderation; borrowing information across all the genes to obtain more precise estimates of gene-wise variability
extracted_contrasts <- eBayes(extracted_contrasts, robust=TRUE)
  ## Plot the model's residual variances against average expression values; demonstrating that the variance is no longer dependent on the mean expression level
plotSA(extracted_contrasts, main="Final model: Mean-variance trend")
  ## Identify which genes are significantly differentially expressed for each contrast from a fit object containing p-values and test statistics
extracted_contrasts$sig <- decideTests(extracted_contrasts, lfc = 0)
```

```{r}
createResTables <- function(obj) {
  resultsTables <- list()
  for (contrast in colnames(obj$contrasts)) {
    resultsTables[[contrast]] <- topTable(obj, coef = contrast, n = Inf) %>%
      # as_tibble(rownames = "gene") %>%
      dplyr::rename(log2FoldChange = logFC, pvalue = P.Value, padj = adj.P.Val)
  }
  return(resultsTables)
}

# Arrange by cluster, then by contrast
resTables <- createResTables(extracted_contrasts)

# Put all the results in a single table
resTable_AllOneTbl <- lapply(resTables, function(one_tbl) {
    one_tbl %>%
    rownames_to_column(var = "gene")
  }) %>% bind_rows(., .id = "contrast")
```

# Results table

```{r}
resTable_AllOneTbl
```

# Visualize coefficients

These are currently being added to gencoreBulk, but are here until pushed to main

```{r}
#' Return a simple ggplot boxplot of gene expression
#'
#' Returns a simple ggplot of gene expression, optionally with jitter or 
#'  boxplots overlayed. These are optional in case you want to do other 
#'  aesthetics. This is meant to be minimal so you can adjust the aesthetics
#'  as necessary, but it can still be used as a quick check. 
#'  
#' @param gene Gene to plot expression for
#' @param counts The expression data to plot
#' @param metadata The metadata to associate with the counts data
#' @param grouping Variable to group expression by. Must be a column of `metadata`
#' @param groups Optional specification of level ordering for grouping var
#' @param subsetting Optional variable to subset expression by. Must be a column of `metadata`
#' @param subsets Specification of levels to subset for
#' @param boxplot Boolean, plot `geom_boxplot`?
#' @param jitter Boolean, plot `geom_jitter`?
#' @param axis_text_x Option to modify X axis text. Default rotates labels 90
#'  degrees
#'
#' @returns A ggplot object
#' @export
#'
#' @import ggplot2
#' @importFrom rlang .data
#' @importFrom utils stack
#' @examples
#' \dontrun{
#' 
#'   ## With a limma model fit
#'   plotGeneExpression('MAMU-A', counts = model_fit$EList$E, metadata = model_fit$targets, grouping = 'groupIDs')
#'   
#'   ## With a DESeq model
#'   plotGeneExpression('MAMU-A', counts = assay(assays(analysis$dds)$rld), 
#'                      metadata = colData(analysis$dds), grouping = 'groupIDs')
#' }
#' 
plotGeneExpression <- function(gene,
                               grouping,
                               groups,
                               counts,
                               metadata,
                               subsetting,
                               subsets,
                               boxplot = TRUE,
                               jitter = TRUE,
                               axis_text_x = element_text(angle = 90, vjust = 0.5, hjust=1)) {
  # if (missing(gene) | missing(grouping) | missing(counts) | missing(metadata)) {
  #   stop('The following arguments are all required: gene, grouping, groups, counts, metadata')
  # }
  if (!(gene %in% rownames(counts))){
    stop('Gene not found in counts data')
  }
  if (!grouping %in% colnames(metadata)) {
    stop('grouping variable not found in metadata')
  }
  if (xor(missing(subsetting), missing(subsets))) {
    stop('Subsetting data requires both subsets and subsetting to be specified')
  } 
  if (any(colnames(counts) != rownames(metadata))) {
    warning('Colnames of counts does not match rownames of metadata. Continuing, but
            this may suggest the data are not properly associated')
  }
  if (!missing(subsetting)) {
    if (!subsetting %in% colnames(metadata)) {
      stop('subsetting variable not found in metadata')
    }
    metadata <- metadata[metadata[[subsetting]] %in% subsets,]
    counts <- counts[,rownames(metadata)]
  }
  plotdata <- utils::stack(counts[gene, ])
  colnames(plotdata) <- 'Gene'
  plotdata$grouping <- metadata[[grouping]]
  if (!missing(groups)) {
    if (!all(groups %in% unique(metadata[[grouping]]))) {
      stop('All groups not found in grouping variable of metadata')
    }
    plotdata$grouping <- factor(plotdata$grouping, levels = groups)
  }
  ggplot2::ggplot(plotdata, aes(x=grouping, y=.data[['Gene']])) + 
    (if (boxplot) { ggplot2::geom_boxplot(outlier.color = if (jitter) {NA} else {'black'}) }) +
    (if (jitter) { ggplot2::geom_jitter() }) +
    ggplot2::theme_bw() +
    ggplot2::labs(x = 'Group', y = 'Expression', main = gene) +
    ggplot2::theme(axis.text.x = axis_text_x)
}




#' Plot the results of a model fit 
#' 
#' Plots the expression, coefficients, and estimated change for a single gene and
#' contrast. 
#' 
#' For example, if the question is:
#'  "the results say JUNB has a significant increase in expression,
#'   in Day 14 compared to day 0, does this seem to be true?"
#' 
#' You might subset the counts data on 'day', selecting only day 14 and 0 to focus the figure.
#'
#' @param gene Gene to plot
#' @param contrast Name of contrast, must be present in `contrasts`
#' @param coefficients Matrix of coefficients fit by model of your choice
#' @param contrasts Dataframe of contrasts, with columns for contrast name, 
#'  numerator, and denominator
#' @inheritParams plotGeneExpression
#'
#' @returns A ggplot object
#' @export
#' 
#' @import ggplot2
#'
#' @examples 
#' \dontrun{ 
#' 
#' contrast_matrix_expanded <- data.frame(
#'   contrast_names = 'P14_grp3vgrp2',
#'   numerators = '(Intercept) + grpgrp3',
#'   denominators = '(Intercept)')
#'   
#' model_plot('JUN', contrast = 'P14_grp3vgrp2',
#'              counts = model_fit$EList$E, metadata = model_fit$targets,
#'              grouping = 'grp.day',
#'              subsetting = 'grp.day', subsets = c('grp2.P14', 'grp3.P14'),
#'              coefficients = limma_fit$fit$coefficients,
#'              contrasts = contrast_matrix_expanded)
#' }
model_plot <- function(gene, contrast, 
                       counts, metadata, 
                       grouping, groups, 
                       subsetting, subsets,
                       coefficients, contrasts) { 
  baseplot <- plotGeneExpression(gene,
                                 counts =  counts,
                                 metadata = metadata,
                                 grouping = grouping,
                                 groups = groups,
                                 subsetting = subsetting,
                                 subsets = subsets)
  contrast_coeffs <- contrasts[contrasts$contrast_names == contrast,]
  contrast_coeffs <- .extract_coefficients(gene = gene, 
                                          contrast = contrast_coeffs, 
                                          coefficients = coefficients)
  contrast_num <- round(contrast_coeffs$numerator, 2)
  contrast_den <- round(contrast_coeffs$denominator, 2)
  contrast_line_num <- ggplot2::geom_hline(yintercept = contrast_num, linetype = 'dashed') 
  contrast_line_den <- ggplot2::geom_hline(yintercept = contrast_den, linetype = 'dashed') 
  
  arrow <- ggplot2::geom_segment(aes(x = 1.5, xend = 1.5, 
                            y = contrast_den, 
                            yend = contrast_num),
                        arrow = ggplot2::arrow()) 
  baseplot + 
    contrast_line_num +
    contrast_line_den +
    arrow +
    ggplot2::scale_y_continuous(breaks = c(contrast_den, contrast_num))
}

.extract_coefficients <- function(gene,
                                  coefficients,
                                  contrast) {
  if (!gene %in% rownames(coefficients)) {
    stop('Gene not found in coefficients')
  }
  coefficients <- coefficients[gene,]
  numerator_terms <- unlist(strsplit(contrast$numerators, '\\s*\\+\\s*', perl = TRUE))
  numerator <- 0
  for (term in numerator_terms) {
    if (!term %in% names(coefficients)) {
      stop(paste0("Error in numerator specification. Term '", term,
                  "' not found in matrix of coefficients"))
    }
    numerator <- numerator + unname(coefficients[term])
  }
  denominator_terms <- unlist(strsplit(contrast$denominators, '\\s*\\+\\s*', perl = TRUE))
  denominator <- 0
  for (term in denominator_terms) {
    if (!term %in% names(coefficients)) {
      stop(paste0("Error in denominator specification. Term '", term,
                  "' not found in matrix of coefficients"))
    }
    denominator <- denominator + unname(coefficients[term])
  }
  return(list(contrast_name = contrast$contrast_names, numerator = numerator, denominator = denominator))
}

```


```{r}

plotGeneExpression('JUN',
                   counts =  model_fit$EList$E,
                   metadata = model_fit$targets,
                   grouping = 'grp.day')
```

You can try to add coefficient terms too to see if they track with your expectations

```{r}
model_plot('JUN', contrast = 'P14_grp3vgrp2',
           counts = model_fit$EList$E, metadata = model_fit$targets,
           grouping = 'grp.day',
           subsetting = 'grp.day', subsets = c('grp2.P14', 'grp3.P14'),
           coefficients = model_fit$coefficients, 
           contrasts = contrast_matrix_expanded)
```
