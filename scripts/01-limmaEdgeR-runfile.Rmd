---
title: "bulk_RNAseq_Analysis"
author: "ENPRC Genomics Core"
date:  "`r Sys.Date()`"
output: 
  rmdformats::robobook:
    fig_width: 9
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = TRUE,
                      message = TRUE, 
                      echo=FALSE, 
                      fig.width = 8, 
                      fig.height = 4)
```

# Libraries

```{r}
library(tidyverse)
library(limma)
library(edgeR)
library(gencoreBulk)
library(here)
# library(msigdbr)
source(here("R/voomByGroup.R"))
```


# Outline of workflow

1. Read in data and create `bulk` object
  - Read in counts from STAR output
  - Add sample metadata to `bulk` object
  - Add design to `bulk` object
2. Filter by expression
  - Run `FilterByExpr()`
  - Visualize library sizes and gene counts before and after filtering
3. PCA
  - Using ggplot version of output of `plotMDS()`
4. Define contrasts
  - Keep this separate from the `bulk` object for flexibility
5. DE diagnostics
  - Run `voomLmFit()` or `glmQLFit()`
  - Generate results tables
  - Plot MD
  - Plot p-value distributions
  - Summarize DEG counts in each contrast
  - Export results list to excel file

## Report metadata

These variables help assign filenames to outputs and reports so you can rerun this script with different parameters without mixing up or overwriting files you want to track or compare.

```{r}
project_name <- "p23131_Tomas_RNAseq"
report_number <- "01"
report_title_root <- "QC+DE"
```


# 0 - Custom functions

To do: Move this to `R/` and/or `gencoreBulk` if these prove useful

```{r}
runEdgeRVoomLmFit <- function(bulkObj, contr.matrix, block = NULL, sample.weights = TRUE, var.design = NULL, var.group = NULL, plotVoom = TRUE) {
  ## This function adapts the limma voom method (Law et al, 2014) to allow for loss of residual degrees of freedom due to exact zero counts (Lun and Smyth, 2017). 
  ## The function is analogous to calling voom followed by duplicateCorrelation and lmFit except for the modified residual df values and residual standard deviation sigma values.
  ## If block is specified, then the intra-block correlation is estimated using duplicateCorrelation In that case, the voom weights and the intra-block correlation are each estimated twice to achieve effective convergence.
  ## Empirical sample quality weights will be estimated if sample.weights=TRUE or if var.design or var.group are non-NULL (Liu et al 2015). In that case, voomLmFit is analogous to running voomWithQualityWeights followed by lmFit.
  bulkObj$fit <- edgeR::voomLmFit(counts = bulkObj$dge$counts, 
                                   design = bulkObj$md$design,
                                   block = block,
                                   sample.weights = sample.weights,
                                   var.design = var.design,
                                   var.group = var.group,
                                   plot = plotVoom)
  ## Re-orient the fitted model object from the coefficients of the original design matrix to the set of contrasts defined above in contr.matrix
  bulkObj$fit <- contrasts.fit(bulkObj$fit, 
                                contrasts = contr.matrix)
  ## Run empirical Bayes moderation; borrowing information across all the genes to obtain more precise estimates of gene-wise variability
  bulkObj$fit <- eBayes(bulkObj$fit, robust=TRUE)
  ## Plot the model's residual variances against average expression values; demonstrating that the variance is no longer dependednt on the mean expression level
  plotSA(bulkObj$fit, main="Final model: Mean-variance trend")
  ## Identify which genes are significantly differentially expressed for each contrast from a fit object containing p-values and test statistics
  bulkObj$de <- decideTests(bulkObj$fit, lfc = 0)
  return(bulkObj)
}

runGlmQLFit <- function(bulkObj, contr.matrix) {
  bulkObj$dge <- estimateDisp(bulkObj$dge, bulkObj$md$design)
  plotBCV(bulkObj$dge)
  bulkObj$fit <- glmQLFit(bulkObj$dge, bulkObj$md$design, robust = TRUE)
  bulkObj$res <- list()
  for (i in 1:ncol(contr.matrix)){
    bulkObj$res[[i]]<- glmQLFTest(bulkObj$fit, contrast = contr.matrix[,i])
  }
  names(bulkObj$res) <- colnames(contr.matrix)
  return(bulkObj)
}

createResTable <- function(clustObj) {
  resultsTables_list <- list()
  for (contrast in colnames(clustObj$fit$coefficients)) {
    resultsTables_list[[contrast]] <- topTable(clustObj$fit, coef = contrast, n = Inf) %>%
      # as_tibble(rownames = "gene") %>%
      dplyr::rename(log2FoldChange = logFC, pvalue = P.Value, padj = adj.P.Val)
  }
  
  resultsTable <- lapply(resultsTables_list, function(one_tbl) {
    one_tbl %>% rownames_to_column(var = "gene")
  }) %>% bind_rows(., .id = "contrast") %>%
    as_tibble()
  
  return(resultsTable)
}
```

```{r}
getVoomByGroupData <- function(bulk, group, ...) {
  vbg <- voomByGroup(counts = bulk$dge$counts, 
                     design = bulk$md$design, 
                     group = bulk$dge$samples[[group]], 
                     plot = "combine", save.plot = TRUE)
  
  vbg_plot_data <- 
    lapply(names(vbg$voom.line), function(grp) {
      as_tibble(vbg$voom.line[[grp]]) %>%
        mutate(group = grp) %>%
        distinct()
    }) %>% bind_rows()
    
  return(vbg_plot_data)
}

plotVoomByGroupData <- function(vbg_data, ...) {
  vbg_data %>%
    ggplot(data = ., aes(x = x, y = y, color = group)) +
    geom_line() +
    scale_color_brewer(palette = "Paired") +
    xlab("log2( count size + 0.5 )") +
    ylab("Sqrt( standard deviation )") +
    theme_classic()
}

ggplotMDS <- function(dge, group = "group", sampleID = "sampleID", gene.selection = "common", ...) {
  mds_data <- plotMDS(dge, top = 500,
                      labels = dge$samples[[group]], 
                      col = col.group, plot = FALSE, 
                      gene.selection, ...)
  
  mds_xy <- mds_data[c("x","y")] %>% as_tibble()
  mds_xy[[sampleID]] <- colnames(dge)
  # mds_xy[[sampleID]] <- str_extract(colnames(dge), "(^[A-Za-z0-9]*)")
  mds_xy <- mds_xy %>% full_join(dge$samples, by = sampleID)
  
  x_varex <- round(mds_data$var.explained[1]*100, digits = 0)
  y_varex <- round(mds_data$var.explained[2]*100, digits = 0)
  
  mds_xy %>%
  ggplot(aes(x = .data$x, y = .data$y, color = .data[[group]], label = .data[[sampleID]])) +
    geom_text() + 
    scale_color_brewer(palette = "Paired") +
    xlab(paste0(mds_data$axislabel, " 1 (", x_varex, "%)")) +
    ylab(paste0(mds_data$axislabel, " 2 (", y_varex, "%)")) +
    theme_classic() +
    theme(aspect.ratio = 1) +
    coord_cartesian(clip = "off") +
    ggtitle(ifelse(gene.selection == "common", "PCA", "MDS"))
}
```

```{r}
# Note that this only works for a design with a single factor for the moment
# To do: Generalize to designs with more 2 or more factors
makeSamplesPerContrastTable <- function(contr.matrix, bulkObj) {
  ## Make table of the numerators and denominators of each contrast
  contr.levels <- tibble(contrast = colnames(contr.matrix))
  for (icol in 1:ncol(contr.matrix)) {
    contr.levels[icol, 2] <- names(which(contr.matrix[,icol]==1))
    contr.levels[icol, 3] <- names(which(contr.matrix[,icol]==-1))
  }
  colnames(contr.levels)[2] <- "numerator"
  colnames(contr.levels)[3] <- "denominator"
  
  # Column of sample metadata table to pull grouping factor from
  fct_name <- names(attr(bulkObj$md$design, "contrasts"))
  
  contr.levels_tbl <- contr.levels %>%
    pivot_longer(cols = -contrast, names_to = "type", values_to = "level") %>%
    mutate(level = str_remove(level, paste0("^", fct_name))) %>%
    full_join(count(bulkObj$dge$samples, .data[[fct_name]], name = "nSamples"), 
              by = c("level" = fct_name)) %>%
    select(-level) %>%
    pivot_wider(names_from = type, values_from = nSamples)
  
  return(contr.levels_tbl)
}
```



# 1 - Read in data and create `bulk` object

```{r}
## `bulk` object will contain project metadata, sample metadata, counts tables, and model fits
bulk <- list()
```

## 1.1 - Read/set project config

May move this to a yaml as for the DESeq2 version. Leaving here for clarity.

```{r}
bulk$md$project <- "p23131_Tomas_RNAseq"
bulk$md$refDir <- "/yerkes-cifs/runs/Genome_references/composite/macaca_mulatta_siv/Mmul10_SIVsm804ECL757/STAR-2.7.9a"
bulk$md$alignDir <- "/yerkes-cifs/runs/Analysis/2023_Analyses/p23131_Tomas/processing/STAR-2.7.9a"
bulk$md$dropSamples <- c()
bulk$md$libraryType <- "antisense"
bulk$md$STARreadSuffix <- "_ReadsPerGene.out.tab"

## Subset of samples from p23131_Tomas project for demonstration purposes
bulk$md$sampleTable <- tibble(
  fileID = c("p23131-s008_RJu20-April-6-2023-Day-0-Inclacumab",
               "p23131-s029_RLn21-May-18-2023-Day-0-Inclacumab",
               "p23131-s006_RRk19-April-6-2023-Day-0-Inclacumab",
               "p23131-s018_RJu20-April-27-2023-Day-21-post-infection-Inclacumab",
               "p23131-s039_RLn21-June-15-2023-Day-21-post-infection-Inclacumab",
               "p23131-s016_RRk19-April-27-2023-Day-21-post-infection-Inclacumab",
               "p23131-s009_RCn20-April-6-2023-Day-0",
               "p23131-s030_RDd21-May-18-2023-Day-0",
               "p23131-s026_RHy19-May-18-2023-Day-0",
               "p23131-s019_RCn20-April-27-2023-Day-21-post-infection",
               "p23131-s040_RDd21-June-15-2023-Day-21-post-infection",
               "p23131-s036_RHy19-June-15-2023-Day-21-post-infection"),
  animalID = c("RJu20", "RLn21", "RRk19", 
               "RJu20", "RLn21", "RRk19",
               "RCn20", "RDd21", "RHy19",
               "RCn20", "RDd21", "RHy19"),
  day = c("D0", "D0", "D0", 
          "D21", "D21", "D21",
          "D0", "D0", "D0", 
          "D21", "D21", "D21"),
  trt = c("I", "I", "I", 
          "I", "I", "I",
          "U", "U", "U", 
          "U", "U", "U")
)

bulk$md$sampleTable <- bulk$md$sampleTable %>%
  mutate(grp = paste0(trt, "_", day),
         sampleID = paste0(animalID, "_", grp))

```

## 1.2 - Read in counts from STAR output and create DGEList object

### Read in counts and mapping stats
```{r}
## Assemble full path of each read file
bulk$md$sampleTable$readPath <- 
  here(bulk$md$alignDir, bulk$md$sampleTable$fileID, paste0(bulk$md$sampleTable$fileID, bulk$md$STARreadSuffix))

## STAR puts mapping stats in the top 4 lines of the counts table files *ReadsPerGene.out.tab, so can't use edgeR::readDGE() out of the box
counts_tmp <- parseReadPerGeneFiles(file.paths = setNames(bulk$md$sampleTable$readPath, 
                                                          nm = bulk$md$sampleTable$sampleID), 
                                    library.type = bulk$md$libraryType)

## Save mapping stats into project metadata for plotting later
bulk$md$mapBins <- counts_tmp$map_bins
```

### Create DGEList
```{r}
bulk$dge <- DGEList(counts = counts_tmp$read_counts, 
                    samples = bulk$md$sampleTable %>% dplyr::select(-readPath), # remove paths from dge sample metadata because they are really long
                    group = bulk$md$sampleTable$grp)

## Don't need this anymore
rm(counts_tmp)
```

### Assign gene symbols from reference gtf as gene IDs
```{r}
## STAR output may use Ensembl IDs as gene IDs, in which case, use gtf to assign gene symbols where possible
geneInfoTab <- read_tsv(here(bulk$md$refDir, "geneInfo.tab"),
                        skip = 1,
                        col_names = c("gene_id","gene_symbol","gene_type"))

# Remove samples if there are fewer total fragment counts than features
lowcounts <- colSums(bulk$dge$counts) < nrow(geneInfoTab)
stopifnot(!sum(lowcounts)>0)

gene_names <- plyr::mapvalues(rownames(bulk$dge$counts), 
                              from = geneInfoTab$gene_id,
                              to = geneInfoTab$gene_symbol)

# Save original ensembl names in case you want to write it out
raw_counts_ensembl <- bulk$dge$counts
rownames(bulk$dge$counts) <- make.names(gene_names, unique=TRUE)
```

## 1.3 - Add design to `bulk` object

See `https://bioconductor.org/packages/release/workflows/vignettes/RNAseq123/inst/doc/designmatrices.html` for detailed guidance on how to choose a design matrix for a given experiment.
Here we use combined two factors, `trt` and `day`, into a single factor `grp`. Note that this is a repeated measures experiment and we will fit the model using a random effect downstream.
```{r}
bulk$md$design <- model.matrix(~ 0 + grp, data = bulk$md$sampleTable)
```

## 1.4 - Correct gene names based on gtf

```{r gene_names, include=TRUE}
geneInfoTab <- read_tsv(here(bulk$md$refDir, "geneInfo.tab"),
                        skip = 1,
                        col_names = c("gene_id","gene_symbol","gene_type"),
                        show_col_types = FALSE)

## Remove samples if there are fewer total fragment counts than features
## Could catch a technical error if data isn't loading correctly (but you should see this in the mapping plot)
lowcounts <- colSums(bulk$dge$counts) < nrow(geneInfoTab)
stopifnot(!sum(lowcounts)>0)

gene_names <- plyr::mapvalues(rownames(bulk$dge$counts), 
                              from=geneInfoTab$gene_id,
                              to=geneInfoTab$gene_symbol)

## Save original ensembl names in case you want to write it out
raw_counts_ensembl <- bulk$dge$counts
rownames(bulk$dge$counts) <- make.names(gene_names, unique=TRUE)
```

## 1.5 - Plot mapping stats

```{r mapping_plot, fig.width=8, fig.height=6}
mappingBinsPlot(bulk$md$mapBins)
```

# 2 - Filter by expression

```{r}
keep.exprs <- filterByExpr(bulk$dge)
```

## 2.1 - Gene filtering by expression
```{r}
bulk$dge$counts %>%
  as_tibble(rownames = "gene") %>%
  left_join(tibble(gene = names(keep.exprs), keep = keep.exprs), 
            by = c("gene")) %>%
  pivot_longer(cols = -c(gene, keep), names_to = "sampleID", values_to = "counts") %>%
  mutate(is_zero = counts == 0) %>%
  group_by(sampleID, keep) %>%
  summarize(keep_zero = sum(is_zero & keep),
            keep_nonzero = sum(!is_zero & keep),
            remove_zero = sum(is_zero & !keep),
            remove_nonzero = sum(!is_zero & !keep)) %>%
  pivot_longer(cols = c(starts_with("keep_"), starts_with("remove_")), names_to = "cat", values_to = "n_genes") %>%
  mutate(cat = factor(cat, levels = rev(c("keep_nonzero", "keep_zero", "remove_nonzero", "remove_zero")))) %>%
  ggplot(aes(y = sampleID, x = n_genes, fill = cat)) +
  geom_bar(stat="identity") +
  scale_fill_manual(values = c("keep_nonzero"="green2", "keep_zero"="yellow2",
                               "remove_nonzero"="orange", "remove_zero"="red"),
                    breaks = c("keep_nonzero", "keep_zero",
                               "remove_nonzero", "remove_zero")) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

## 2.2 - Library sizes of discarded and kept data
```{r, fig.height=8, fig.width=8}
bulk$dge$counts %>%
  as_tibble(rownames = "gene") %>%
  left_join(tibble(gene = names(keep.exprs), keep = keep.exprs), 
            by = c("gene")) %>%
  pivot_longer(cols = -c(gene, keep), names_to = "sampleID", values_to = "counts") %>%
  group_by(sampleID, keep) %>%
    summarize(lib.size = sum(counts)) %>%
  ungroup() %>%
  ggplot(aes(y = sampleID, x = lib.size, fill = keep)) +
  geom_bar(stat="identity") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

bulk$dge$counts %>%
  as_tibble(rownames = "gene") %>%
  left_join(tibble(gene = names(keep.exprs), keep = keep.exprs), 
            by = c("gene")) %>%
  pivot_longer(cols = -c(gene, keep), names_to = "sampleID", values_to = "counts") %>%
  group_by(sampleID, keep) %>%
    summarize(lib.size = sum(counts)) %>%
  ungroup() %>%
  ggplot(aes(y = sampleID, x = lib.size, fill = keep)) +
  geom_bar(stat="identity") +
  scale_x_log10() +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

## 2.3 - Apply the filter
```{r}
## Save the prefiltered data in case you want to compare
bulk_prefilt <- bulk

## Apply the filter
bulk$dge <- bulk$dge[keep.exprs, , keep.lib.sizes=FALSE]
```


# 3 - Variance-mean trends and PCA
  - Using ggplot version of output of `plotMDS()`

## 3.1 - Mean-variance trend by group (i.e. voomByGroup)

```{r}
vbg_plot <- getVoomByGroupData(bulk, group = "grp") %>%
    plotVoomByGroupData()
```

## 3.2 - PCA plot

**To do: add options for elipses, lines, shapes and color scales as in `gencoreBulk::plotPCAFromConfig()`**

```{r}
ggplotMDS(bulk$dge, group = "grp", gene.selection = "common")
```

## 3.3 - MDS plot

Multidimensional scaling plot; distances correspond to BCV between pairs of samples. Pairwise BCVs were computed from the 500 most heterogeneous genes. See ?limma::plotMDS() for details.

[McCarthy et al. 2012](https://academic.oup.com/nar/article/40/10/4288/2411520)
> Biological coefficient of variation is the coefficient of variation with which the (unknown) true abundance of the gene varies between replicate RNA samples. It represents the CV that would remain between biological replicates if sequencing depth could be increased indefinitely. 

```{r}
ggplotMDS(bulk$dge, group = "grp", gene.selection = "pairwise")
```

  
# 4 - Define contrasts and check sample sizes per contrast

## 4.1 - Define contrasts

```{r}
contr.matrix <- makeContrasts(
  grpI_D21vsD0 = grpI_D21 - grpI_D0,
  grpU_D21vsD0 = grpU_D21 - grpU_D0,
  levels = bulk$md$design
  )
```
  
## 4.2 - Check sample sizes per contrast level

This is more critical for pseudobulk, but it may be useful to check in cases with highly variable/low sample sizes among a large number of contrasts.
```{r}
# Note that this only works for a design with a single factor for the moment
# To do: Generalize to designs with more 2 or more factors
makeSamplesPerContrastTable(contr.matrix, bulk) %>% knitr::kable()
```


# 5 - DE diagnostics

## 5.1 - Run `voomLmFit()` or `glmQLFit()`

```{r}
bulk <- runEdgeRVoomLmFit(bulk, contr.matrix=contr.matrix, sample.weights = TRUE)
```


## 5.2 - Generate results tables

```{r}
resultsTable <- createResTable(bulk)
```

There are two easy ways to access tables split by contrast for different purposes using `for()` or `split()`
```{r}
for (contr in unique(resultsTable$contrast)) {
  resultsTable %>%
    filter(contrast == contr)
}
```

```{r}
resultsTable %>%
  split(., .$contrast)
```


## 5.3 - Plot MD

```{r}
md_data <- resultsTable %>%
    mutate(signif_dir = ifelse(padj >= 0.05, "NotSig",
                           ifelse(log2FoldChange < 0, "Down", "Up")) %>%
             factor(., levels = c("NotSig", "Up", "Down")),
           signif = padj < 0.05)
  
ggplot() +
  geom_point(data = filter(md_data, !signif),
             aes(x = AveExpr, y = log2FoldChange), 
             color = "black", size = 0.1) +
  geom_point(data = filter(md_data, signif), 
             aes(x = AveExpr, y = log2FoldChange, color = signif_dir), 
             size = 0.1) +
  ylim(-max(abs(md_data$log2FoldChange)), max(abs(md_data$log2FoldChange))) +
  scale_color_manual(values = c("black", "red", "blue"), drop = FALSE) +
  theme_bw() +
  facet_wrap(~contrast)
```


## 5.4 - Plot p-value distributions

```{r}
resultsTable %>%
      mutate(`pBH < 0.05` = ifelse(padj < 0.05, "TRUE", "FALSE") %>%
               factor(., levels = c("TRUE", "FALSE"))) %>%
    ggplot(data = ., aes(x = pvalue, fill = `pBH < 0.05`)) +
      geom_histogram(breaks = seq(0,1,0.01)) +
      scale_fill_manual(values = c("red", "black"), drop=FALSE) +
      theme_bw() +
    facet_wrap(~contrast, scales = "free_y")
```

# 6 - DE results

## 6.1 - Summarize DEG counts in each contrast

```{r}
n_deg_summary <- resultsTable %>% 
  group_by(contrast) %>%
    dplyr::rename(l2fc = log2FoldChange, pBH = padj) %>%
    summarize(signif_down = sum(pBH < 0.05 & l2fc < 0),
              nonsignif = sum(pBH >= 0.05),
              signif_up = sum(pBH < 0.05 & l2fc > 0)) %>%
  mutate(signif = signif_up + signif_down)
```

### Table
```{r}
n_deg_summary %>%
  mutate(signif_signs = paste0(signif_up, " ↑ / ", signif_down, " ↓")) %>%
  select(contrast, signif_signs) %>%
  knitr::kable()
```

### Bar plots
```{r, fig.width = 12, fig.height = 8}
n_deg_summary %>%
  pivot_longer(cols = c(signif_down, signif_up), 
               names_to = "sign", 
               values_to = "n_signif") %>%
  mutate(n_signif = ifelse(sign == "signif_down",
                           -n_signif, n_signif)) %>%
  ggplot(aes(y = fct_rev(contrast), x = n_signif, fill = sign)) +
  geom_bar(stat="identity") +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  theme_bw() +
  ylab("contrast")
```


## 6.2 - Export results list to excel file

Create output dir for this report if it doesn't already exist
```{r}
if (!dir.exists(here(paste0("outputs/report-", report_number)))) {
  dir.create(here(paste0("outputs/report-", report_number)))
}
```

### Export excel file with columns for padj and lfc for each contrast
```{r}
resultsTable_for_export <- unique(resultsTable$contrast) %>%
lapply(., function(contr) {
  resultsTable %>% 
    filter(contrast == contr) %>%
    dplyr::select(gene, l2fc = log2FoldChange, pBH = padj)%>%
    dplyr::rename_with(~ paste0(contr, "_", .x, recycle0 = TRUE),
                  all_of(c("l2fc", "pBH")))
}) %>% 
  reduce(full_join, by = "gene")

resultsTable_for_export_filename <- paste0(
  project_name, "-", 
  report_number, "-",
  report_title_root, "-",
  "DE_edgeRvoomLmFit_vqw-", 
  format(Sys.Date(), "%Y%m%d"), ".xlsx"
  )

c(list("Summary" = n_deg_summary), 
  list("ResultsTable" = resultsTable_for_export)) %>%
writexl::write_xlsx(here(paste0("outputs/report-", report_number), resultsTable_for_export_filename))
```

### Export excel file with columns for padj and lfc for each contrast
```{r}
resultsTable_for_export <- unique(resultsTable$contrast) %>%
lapply(., function(contr) {
  resultsTable %>% 
    filter(contrast == contr) %>%
    dplyr::select(gene, l2fc = log2FoldChange, pBH = padj)%>%
    dplyr::rename_with(~ paste0(contr, "_", .x, recycle0 = TRUE),
                  all_of(c("l2fc", "pBH")))
}) %>% 
  reduce(full_join, by = "gene")

resultsTable_for_export_filename <- paste0(
  project_name, "-", 
  report_number, "-",
  report_title_root, "-",
  "DE_edgeRvoomLmFit_vqw-", 
  format(Sys.Date(), "%Y%m%d"), ".xlsx"
  )

c(list("Summary" = n_deg_summary), 
  list("ResultsTable" = resultsTable_for_export)) %>%
writexl::write_xlsx(here(paste0("outputs/report-", report_number), resultsTable_for_export_filename))
```

